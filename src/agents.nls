__includes ["helper.nls"]

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".

  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; local variables
  add_buses       ; if true, add buses
  levels          ; hyperparameter for the depth of the graph
  known_route     ; Assessed route for this bus (with respect to levels hyperparam)
]


globals [
  graph
]


to init-buses
  ; Initialize Agents

  ; This list contains the topology of the entire network of bus stops, which is known to all
  ; agents. This can be used to calculate the shortest path between two bus stops.
  set graph [ [22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13]
              [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18]
              [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]
  ]

  set levels 4
  set known_route []

end


to execute-actions
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.

  if add_buses = 0 [
   if bus_id = 24 or bus_id = 25 or bus_id = 26 or bus_id = 27 or
      bus_id = 28 or bus_id = 29 or bus_id = 30 or bus_id = 31 or
      bus_id = 32 or bus_id = 33 or bus_id = 34 or bus_id = 35 or
      bus_id = 36 or bus_id = 37 or bus_id = 38 or bus_id = 39 or
      bus_id = 40 or bus_id = 41 or bus_id = 42 or bus_id = 43 or
      bus_id = 44 or bus_id = 45 or bus_id = 46 or bus_id = 47 or
      bus_id = 48 or bus_id = 49 or bus_id = 50 or bus_id = 51 or
      bus_id = 52 or bus_id = 53 or bus_id = 54 or bus_id = 55 [
     add-bus 1 set add_buses 1
   ]
  ]

  show "---------------------------------"

  if current_stop > -1 [
    show (word "Current stop: " current_stop)

    foreach bus_passengers [
      if item 1 ? = current_stop [ drop-off-passenger item 0 ? ]
    ]

    let free_spaces free-spaces-on-bus

    if free_spaces > 0 [
      let pass_here map [ item 0 ? ] get-passengers-at-stop current_stop

      ; Only pickup free_spaces number of passengers
      repeat min list free_spaces length pass_here [

        pick-up-passenger item random length pass_here pass_here
        set free_spaces free_spaces - 1
      ]
    ]

    show (word "Passengers that are now on the bus: " bus_passengers)

    ; Check if there is a route available
    ; if not, calculate the route
    if length known_route = 0 [
      set known_route reverse item 0 (choose-next-bus-stop current_stop levels)
    ]

    set next_stop item 0 known_route
    set known_route but-first known_route  ; remove the first element of the known_route
  ]

  show (word "Next stop: " next_stop)
  travel-to next_stop

end


to-report choose-next-bus-stop [ bus_stop level ]
  ; Utility recursion function
  ; Args:
  ;   @bus_stop
  ;   @level: level of recursion
  ;
  ; Return:
  ;   @max of utility

  ; recursion base step
  if level <= 0 [
    let report_value []
    set report_value lput [] report_value
    set report_value lput 0 report_value

    report report_value
  ]

  ; get connecting nodes
  let connecting_nodes item bus_stop graph

  let utilities []
  let routes_1 []
  let max_utility -1000

  foreach connecting_nodes [
    ; Get the utility for each of the connecting nodes, with level = level - 1
    let return_list choose-next-bus-stop ? (level - 1)  ; (recursion step)

    let u item 1 return_list
    set u u + actual_utility ?

    if u > max_utility [
      set max_utility u
    ]

    set utilities lput u utilities
    set routes_1 lput item 0 return_list routes_1
  ]

  ; Get list of max_utilities. If there are multiple stations with the same
  ; utility, then randomly choose one of those stations
  let max_utility_indices []
  let index 0

  foreach utilities [
    if ? = max_utility [
      set max_utility_indices lput index max_utility_indices
    ]
    set index index + 1
  ]

  let select_node item random length max_utility_indices max_utility_indices  ; random bus_stop with the max utility
  let chosen_route item select_node routes_1
  set chosen_route lput item select_node connecting_nodes chosen_route

  let report_list []
  set report_list lput chosen_route report_list
  set report_list lput max_utility report_list

  report report_list
end


to-report actual_utility [ bus_stop ]
  ; Compute the utility on traveling to 'bus stop'
  ; Args:
  ;   @bus_stop
  ; Return:
  ;   @utility

  let capacity bus-capacity

  ; Free spaces in the bus
  let free_spaces free-spaces-on-bus

  ; 'Droppable' passengers in the potential next bus stop
  let dropoffs 0
  foreach bus_passengers [
    if item 1 ? = bus_stop [
      set dropoffs dropoffs + 1
    ]
  ]

  ; alpha
  let alpha free_spaces / capacity

  ; Potential pick ups
  let pickups min list passenger-count-at-bus-stop bus_stop free_spaces

  let utility_value (1 - alpha) * dropoffs + alpha * pickups
  report utility_value

end

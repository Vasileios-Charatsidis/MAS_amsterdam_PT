__includes ["helper.nls"]

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".

  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; local variables
  add_buses       ; if true, add buses
]


globals [
  graph
]


to init-buses
  ; Initialize Agents
  set bus_type 2

  ; This list contains the topology of the entire network of bus stops, which is known to all
  ; agents. This can be used to calculate the shortest path between two bus stops.
  set graph [ [22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13]
              [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18]
              [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]
  ]

end


to execute-actions
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.

  if add_buses = 0 [
   if bus_id = 24 or bus_id = 25 or bus_id = 26 or bus_id = 27 or
      bus_id = 28 or bus_id = 29 or bus_id = 30 or bus_id = 31 or
      bus_id = 32 or bus_id = 33 or bus_id = 34 [
     add-bus 1 set add_buses 1
   ]
  ]

  show "---------------------------------"

  if current_stop > -1 [
    show (word "Current stop: " current_stop)

    foreach bus_passengers [
      if item 1 ? = current_stop [ drop-off-passenger item 0 ? ]
    ]

    let free_spaces free-spaces-on-bus

    if free_spaces > 0 [
      let pass_here map [ item 0 ? ] get-passengers-at-stop current_stop
      
      ; Only pickup free_spaces number of passengers
      repeat min list free_spaces length pass_here [

        pick-up-passenger item random length pass_here pass_here
        set free_spaces free_spaces - 1
      ]

      foreach pass_here [ pick-up-passenger ? ]
    ]

    show (word "Passengers that are now on the bus: " bus_passengers)

    ; check if passenger is on route otherwise take other bus.
    ; change-passenger-destination-to-centraal

    set next_stop choose-next-bus-stop
  ]

  show (word "Next stop: " next_stop)
  travel-to next_stop

end


to-report choose-next-bus-stop
  ; From the current bus stop, choose the next bus stop to visit
  ; Currently we choose the bus stop with the maximum number of passengers
  ; return:
  ;  @ next_stop

  ; Get the connecting nodes of the current bus stop
  let connecting_nodes item current_stop graph

  let utilities []
  let max_utility -1000

  foreach connecting_nodes [
    ; Get the utility for each of the connecting nodes
    let u utility_for_stop ?
 
    if u > max_utility [
      set max_utility u
    ]
 
    set utilities lput u utilities
  ]

  ; Get list of max_utilities. If there are multiple stations with the same
  ; utility, then randomly choose one of those stations
  let max_utility_indices []
  let index 0

  foreach utilities [
    if ? = max_utility [
      set max_utility_indices lput index max_utility_indices
    ]
    set index index + 1
  ]

  show (word "Connecting bus stops: " connecting_nodes)
  show (word "Utilites for stops:   " utilities)

  let select_node item random length max_utility_indices max_utility_indices

  report item select_node connecting_nodes

end


to-report utility_for_stop [ bus_stop ]
  ; Compute the utility for a bus stop
  ; Args:
  ;   @bus_stop
  ; Return:
  ;   @utility

  let capacity bus-capacity

  ; Free spaces in the bus
  let free_spaces free-spaces-on-bus

  ; 'Droppable' passengers in the potential next bus stop
  let dropoffs 0
  foreach bus_passengers [
     if item 1 ? = bus_stop [
       set dropoffs dropoffs + 1
     ]
  ]
  
  ; alpha
  let alpha free_spaces / capacity

  ; Potential pick ups
  let pickups min list passenger-count-at-bus-stop bus_stop free_spaces

  let utility_value (1 - alpha) * dropoffs + alpha * pickups
  report utility_value

end

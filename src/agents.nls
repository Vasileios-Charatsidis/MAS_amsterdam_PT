__includes ["helper.nls"]

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".

  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).
  dropoff_intent  ; ID's of the passengers for which this bus has plans
  has_plan        ; ID's of passengers for which another bus already has a plan, passengers that don't need to be picked up by you. list of lists. list per bus stop
  dropped_off     ; ID's of the passengers that have been dropped of since the last sent message
  planless_hist   ; The history of how many passengers were planless up to some amount of ticks in the past

  ; local variables
  add_buses       ; if true, add buses
]


globals [
  graph
  total_ticks_per_day
  planless_threshold
  need_thresh_1
  need_thresh_2
  need_thresh_3
]


to init-buses
  ; Initialize Agents

  ; This list contains the topology of the entire network of bus stops, which is known to all
  ; agents. This can be used to calculate the shortest path between two bus stops.
  set graph [ [22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13]
              [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18]
              [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]
  ]
  
  ; hyperparameters of the algorithm
  set total_ticks_per_day 1440
  set planless_threshold 100
  set need_thresh_1 0.0
  set need_thresh_2 2.0
  set need_thresh_3 5.0
  
  ; init of bus-own variables
  set dropped_off []
  set planless_hist n-values 10 [0]

end


to execute-actions
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.
  
  ; temporary code  
   set has_plan [[105] [105] [105] [105] [105] [105] [105] [105] [105] [105] [105] [105] [105] [105] [105] [105] [105] [105] [105] [105] [105] [105] [105] [105]]
   
  ; set dropoff_intent [105]

  ;if add_buses = 0 [
   ; let n 60
    ;let iter n-values n [ ? + 23 ]
    ;foreach iter [
   ; if bus_id = ? [
    ; add-bus 1 set add_buses 1 
     ;]
    ;]
  ;]
  

  ; decide whether to add a new bus this tick
  if bus_id = 24 [ ; bus 24 is the 'president bus'
    let var decide_add_bus planless_threshold
    ; let decision item 0 var
    let decision True
    let planless item 1 var
    set planless_hist lput planless but-first planless_hist
    if (decision = True)  [
      let need new_bus_need planless_hist
      if need > need_thresh_1 [
        ifelse need > need_thresh_2 [
          ifelse need > need_thresh_3 [
            add-bus 3
          ][
            add-bus 2
          ]
        ][
          add-bus 1
        ]
      ]
    ]
  ]

  ; if we've reached the station
  if current_stop > -1 [
    ; drop-off passangers
    foreach bus_passengers [
      if item 1 ? = current_stop [ 
        let pass_id item 0 ?
        drop-off-passenger pass_id
        set dropped_off lput pass_id dropped_off ; save info that we've dropped off this passenger so that we can tell the other busses to forget this info come next message. This will prevent blowing up the size of the has_plan list
      ]
    ]

    ; pick-up passengers
    let free_spaces free-spaces-on-bus
    if free_spaces > 0 [
      let pass_here map [ item 0 ? ] get-passengers-at-stop current_stop
      ; Only pickup free_spaces number of passengers
      repeat min list free_spaces length pass_here [
        ; TO DO: smart pickup, only pick up passengers that we have defined in dropoff-intent
        pick-up-passenger item random length pass_here pass_here
        set free_spaces free_spaces - 1
      ]
      foreach pass_here [ pick-up-passenger ? ]
    ]
    set next_stop choose-next-bus-stop
  ]

  travel-to next_stop
  
  ; if route has been traveled, infer new route and dropoff-intent and communicate
  ; we could consider to only read messages before planning a route or read in messages as soon as they are received, wouldn't matter

end

to-report new_bus_need [ history ]
  ; the need for a bus is determined by how steeply the amount of planless passengers increased in the past few ticks
  ; also influenced by the time of day, later in the day we'll be more hesitant to buy new busses
  let discounted .8 ; the factor with which we want to multiply need at the end of the day
  let angle linear_fit history
  let time_factor 1 - (( ( 1 - discounted ) * ticks) / total_ticks_per_day )
  report angle * time_factor
end
  

to-report linear_fit [ l ]
  let dt []
  let iter n-values ( length l - 1 ) [?]
  foreach iter [
     set dt lput ( (item (? + 1) l - (item ? l) )) dt
  ] 
  let angle sum dt / length dt
  report angle
end

to-report decide_add_bus [threshold] 
  let decision False
  let total_waiting 0
  let num_stations length graph - 1
  let stations n-values num_stations [?] 
  
  foreach stations [
    if length get-passengers-at-stop ? > 0 [
    set total_waiting total_waiting + length item 0 get-passengers-at-stop ?
    ]
  ]
  let planless total_waiting - length has_plan
  
  if planless > threshold [
    set decision True
  ]
  report ( list decision planless )
  
end

to-report choose-next-bus-stop
  ; From the current bus stop, choose the next bus stop to visit
  ; Currently we choose the bus stop with the maximum number of passengers
  ; return:
  ;  @ next_stop

  ; Get the connecting nodes of the current bus stop
  let connecting_nodes item current_stop graph

  let utilities []
  let max_utility -1000

  foreach connecting_nodes [
    ; Get the utility for each of the connecting nodes
    let u utility_for_stop ?
 
    if u > max_utility [
      set max_utility u
    ]
 
    set utilities lput u utilities
  ]

  ; Get list of max_utilities. If there are multiple stations with the same
  ; utility, then randomly choose one of those stations
  let max_utility_indices []
  let index 0

  foreach utilities [
    if ? = max_utility [
      set max_utility_indices lput index max_utility_indices
    ]
    set index index + 1
  ]

  ;show (word "Connecting bus stops: " connecting_nodes)
  ;show (word "Utilites for stops:   " utilities)

  let select_node item random length max_utility_indices max_utility_indices

  report item select_node connecting_nodes

end


;TODO has_plan = list of id`s of people who have a plan
;has_plan list of lists , index indicates bus stop
;assumes has_plan is global

to-report utility_for_stop [ bus_stop ]
  ; Compute the utility for a bus stop
  ; Args:
  ;   @bus_stop
  ; Return:
  ;   @utility
  
  let capacity bus-capacity

  ; Free spaces in the bus
  let free_spaces free-spaces-on-bus
  

  ; 'Droppable' passengers in the potential next bus stop
  let dropoffs 0
  foreach bus_passengers [
     if item 1 ? = bus_stop [
       set dropoffs dropoffs + 1
     ]
  ]
  
  ; alpha
  let alpha free_spaces / capacity
  
  ; set number of passengers at stop to number of passengers without a plan
  let number_have_plan length item bus_stop has_plan
  let number_at_stop passenger-count-at-bus-stop bus_stop - number_have_plan
  
  ; Potential pick ups
  let potential_pickups min list number_at_stop free_spaces
  
  ; count overlapping destinations
  let overlapp 0
  foreach bus_passengers [
    let passenger_destination item 1 ?
    foreach get-passengers-at-stop bus_stop [
      if item 1 ? = passenger_destination [
       set overlapp overlapp + 1
      ]
    ]
    
    ]
  
  
  ; set pickups to mean of possible pickups and number of passengers with same destination as the ones onboard
  ; only do this if the bus is not empty?
  let pickups mean list potential_pickups overlapp
  let utility_value (1 - alpha) * dropoffs + alpha * pickups 
  report utility_value
end

to-report construct_outgoing_message
  ; after the flag "p" come the passengers for which this bus has plans. Other buses don't need to consider helping them
  ; after the flag "d" come the passengers that have been dropped of since the last message
  ; [ "p 105 106 110 d 98 100 " ]
  
  let msg ["p"]
  foreach dropoff_intent [
    set msg lput ? msg  
  ]
  set msg lput "d" msg
  foreach dropped_off [
    set msg lput ? msg
  ]
  set dropped_off [] ; forget from memory to prevent blowing up the size of this variable
  
  set msg lput " " msg
  report (word msg)  
end

to digest_msg [ msg ]
  ; get which passengers are to be added to has_plan and which can be forgotten
  
  ; initialise variables
  let l []
  let start_id 0
  let cur_id 0
  
  let split_idx position "d" msg  
  let msg_p substring msg 0  split_idx ; message on passengers for which there is a plan
  let msg_d substring msg split_idx length msg ; message on passengers that have been dropped off by other buses
  
;  show "variable has_plan before digesting the message"
;  show has_plan

  ; read the part of the message about passengers that have been dropped of
  let iter n-values length msg_d [ ? ] 
  foreach iter [
    if item ? msg_d = "d" or item ? msg_d = " " [
      let var substring msg_d (start_id + 1) (cur_id + 1)
      if length var > 0 [
        set l lput var l 
      ]
      set start_id ?
    ]
    set cur_id ?
  ]
  set l map [ read-from-string ? ] l
  
  ; remove passengers that have been dropped off from the variable has_plan
  let i 0
  foreach has_plan [
    let has_plan_here ? 
    foreach l [
      if member? ? has_plan_here [
        let idx position ? has_plan_here
        set has_plan_here remove-item idx has_plan_here
      ]
      set has_plan replace-item i has_plan has_plan_here
      set i ( i + 1 )
    ]
  ]    
  ; read the part of the message about passengers for which there is a plan
  set l []
  set start_id 0
  set cur_id 0
  set iter n-values length msg_p [ ? ] 
  foreach iter [
    if item ? msg_p = "p" or item ? msg_p = " " [
      let var substring msg (start_id + 1) (cur_id + 1)
      if length var > 0 [
        set l lput var l 
      ]
      set start_id ?
    ]
    set cur_id ?
  ]
  set l map [ read-from-string ? ] l
  
  ; add passengers for which there is a plan to the variable has_plan
  set iter n-values 24 [ ? ]
  foreach iter [
    let bus_stop ?
    let pass get-passengers-at-stop bus_stop
    foreach l [
      if member_nested_list ? pass [ ; will be "false" if this passenger is not part of the list pass
        let has_plan_here (item bus_stop has_plan)
        set has_plan_here lput ? has_plan_here
        set has_plan replace-item bus_stop has_plan has_plan_here
      ]
    ]
  ]
  
;  show "variable has_plan after digesting the message"
;  show has_plan
  
end

to communicate
  
  ; send
  ; TO DO condition for when to construct an outgoing message
  if true [ 
    let msg_str construct_outgoing_message
    let n_bus count buses
    let bus_ids n-values n_bus [ ? + 24 ]
    foreach bus_ids [
      if ? != bus_id [
        send-message ? msg_str
      ]
    ]
  ]
  
  ; read
  foreach inbox [
    ; can we remove stuff from the inbox?
    let t item 0 ?
    if t = ticks - 1 [
      let sender_id item 1 ?
      let msg item 2 ?
      digest_msg msg     
    ]
  ] 
 end

to-report member_nested_list [ i l ]
  let bool false
  foreach l [
    if member? i ? [
      set bool true
    ]
  ]
  report bool
end

__includes ["helper.nls"]

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".

  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; local variables
  add_buses       ; if true, add buses
]


globals [
  graph
]


to init-buses
  ; Initialize Agents

  ; This list contains the topology of the entire network of bus stops, which is known to all
  ; agents. This can be used to calculate the shortest path between two bus stops.
  set graph [ [22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13]
              [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18]
              [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]
  ]

end


to execute-actions
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.

  if add_buses = 0 [
   if bus_id = 24 or bus_id = 25 or bus_id = 26 or bus_id = 27 or
      bus_id = 28 or bus_id = 29 or bus_id = 30 or bus_id = 31 or
      bus_id = 32 or bus_id = 33 or bus_id = 34 [
     add-bus 1 set add_buses 1
   ]
  ]

  ;show "---------------------------------"

  if current_stop > -1 [
    ;show (word "Current stop: " current_stop)

    foreach bus_passengers [
      if item 1 ? = current_stop [ drop-off-passenger item 0 ? ]
    ]

    let free_spaces free-spaces-on-bus

    if free_spaces > 0 [
      let pass_here map [ item 0 ? ] get-passengers-at-stop current_stop
      
      ; Only pickup free_spaces number of passengers
      repeat min list free_spaces length pass_here [

        pick-up-passenger item random length pass_here pass_here
        set free_spaces free_spaces - 1
      ]

      foreach pass_here [ pick-up-passenger ? ]
    ]

   ; show (word "Passengers that are now on the bus: " bus_passengers)

    ; check if passenger is on route otherwise take other bus.
    ; change-passenger-destination-to-centraal

    set next_stop choose-next-bus-stop
  ]

  ;show (word "Next stop: " next_stop)
  travel-to next_stop
  
  communicate

end


to-report choose-next-bus-stop
  ; From the current bus stop, choose the next bus stop to visit
  ; Currently we choose the bus stop with the maximum number of passengers
  ; return:
  ;  @ next_stop

  ; Get the connecting nodes of the current bus stop
  let connecting_nodes item current_stop graph

  let utilities []
  let max_utility -1000

  foreach connecting_nodes [
    ; Get the utility for each of the connecting nodes
    let u utility_for_stop ?
 
    if u > max_utility [
      set max_utility u
    ]
 
    set utilities lput u utilities
  ]

  ; Get list of max_utilities. If there are multiple stations with the same
  ; utility, then randomly choose one of those stations
  let max_utility_indices []
  let index 0

  foreach utilities [
    if ? = max_utility [
      set max_utility_indices lput index max_utility_indices
    ]
    set index index + 1
  ]

  ;show (word "Connecting bus stops: " connecting_nodes)
  ;show (word "Utilites for stops:   " utilities)

  let select_node item random length max_utility_indices max_utility_indices

  report item select_node connecting_nodes

end


to-report utility_for_stop [ bus_stop ]
  ; Compute the utility for a bus stop
  ; Args:
  ;   @bus_stop
  ; Return:
  ;   @utility

  let capacity bus-capacity

  ; Free spaces in the bus
  let free_spaces free-spaces-on-bus

  ; 'Droppable' passengers in the potential next bus stop
  let dropoffs 0
  foreach bus_passengers [
     if item 1 ? = bus_stop [
       set dropoffs dropoffs + 1
     ]
  ]
  
  ; alpha
  let alpha free_spaces / capacity

  ; Potential pick ups
  let pickups min list passenger-count-at-bus-stop bus_stop free_spaces

  let utility_value (1 - alpha) * dropoffs + alpha * pickups
  report utility_value

end

to-report construct_outgoing_message 
  ; constructs a message to other busses saying what the possible routes are this bus can take, what it can do at the stops and what its utility is
  ; "bus_id current_station target_station pickup dropoff utility target_station pickup dropoff utility"
   
  let msg []
  let ground_stop -1 ; if you are on the way to station 5 (you don't cross any other stations), you may pretend that you are sending your message from there
  
  ifelse current_stop > -1 [
    set ground_stop current_stop
  ][
    set ground_stop next_stop
  ]
  
  let connecting_nodes item ground_stop graph
   
  let free_spaces free-spaces-on-bus
  
  set msg lput bus_id msg
  set msg lput ground_stop msg
  
  foreach connecting_nodes [   
    let stations_info [] ; list containing [target_station pickup dropoff utility] or [ [target_station pickup dropoff]*steps_ahead utility ]
    let pickups min list passenger-count-at-bus-stop ? free_spaces
    let dropoffs 0
    foreach bus_passengers [
     if item 1 ? = current_stop [
       set dropoffs dropoffs + 1
      ]
    ]
    let u utility_for_stop ?  
    set stations_info lput ? stations_info  
    set stations_info lput pickups stations_info
    set stations_info lput dropoffs stations_info
    set stations_info lput u stations_info
    set msg lput stations_info msg
  ]

  report (word msg)
end

to-report parse_msg [ msg ]
  ; from a message string, get the relevant info
  let start_id 0
  let cur_id 0
  let l []
  let l2 []
    
  ; parse the string and split at the spaces
  let iter n-values length msg [ ? ] 
  foreach iter [
    if item ? msg = "[" or item ? msg = "]" or item ? msg = " " [
      let var substring msg (start_id + 1) (cur_id + 1)
      if length var > 0 [
        set l lput var l 
      ]
      set start_id ?
    ]
    set cur_id ?
  ]
    
  ; cast to ints
  set l map [ read-from-string ? ] l
  
  ; put in lists. This depends on routelength
  let n_stations (length l - 2) / 4
  set iter n-values n_stations [ ? ] 
  set l2 lput item 0 l l2
  set l2 lput item 1 l l2
  foreach iter [
    let route []
    set route lput item (2 + ? * 4) l route
    set route lput item (3 + ? * 4) l route
    set route lput item (4 + ? * 4) l route
    set route lput item (5 + ? * 4) l route
    set l2 lput route l2
  ]
  
  report l2
end

to-report get_route_from_msg [ msg ]
    ; this function assumes the message to have already been parsed
    ; list containing [target_station pickup dropoff utility] or [ [target_station pickup dropoff]*steps_ahead utility ]
    let steps-ahead 1
    let util_id steps-ahead * 3 
    
    let max_util 0
    let route -1
    let n length msg - 2
    let iter n-values n [ ? + 2 ]
    
    foreach iter [
      let station_info item ? msg
       if item util_id station_info > max_util [
         set max_util item util_id station_info
         set route item 0 station_info
       ]
      ]  
    
    report route
end

to communicate
  ; decide whether to communicate
  if next_stop < 0 [ ; if you don't have a route yet, communicate your intentions with others
    let msg_str construct_outgoing_message
    let n_bus count buses
    let bus_ids n-values n_bus [ ? + 24 ]
    foreach bus_ids [
      if ? != bus_id [
        send-message ? msg_str
      ]
    ]
  ]
  
  foreach inbox [
    ; can we remove stuff from the inbox?
    let t item 0 ?
    if t = ticks - 1 [
      let sender_id item 1 ?
      let msg_str item 2 ?
      let msg parse_msg msg_str
      let route get_route_from_msg msg
      
      ;show msg
      ;show "I" 
      ;show bus_id 
      ;show "see that" 
      ;show sender_id 
      ;show "wants to go to" 
      ;show route
    ]
  ]
  
end

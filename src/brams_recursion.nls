to-report determine_route [ bus_stop level ]
  ; get all possible routes for the amount of levels you have
  ; determine utility per route
     ; utility per station
         ; util a-->b, would-have at B = actual utility(a-->b, would-have at A)
         ; util b-->c, would-have at C = actual utility(b-->, would-have at B)
  ; get maximum utility route
  ; determine dropoff intent based on would-have of max route maybe?
  
  ; would_have like  [ [ pass_id destination "b" (on board)] 
  ;                    [ pass_id destination "d" (already dropped off)] 
  ;                     ... ]
  
  ; utils_routes like [ [ util [ station_id station_id ... ] wouldhave at last station ]
  ;                     [ util [ station_id station_id ... ] wouldhave at last station ] 
  ;                     ... ]
  
  ; initialse some variables
  
  show ( word "bus_passengers: " bus_passengers )
  
  let has [] ; the people the bus HAS on board is the starting point for keeping track of which passengers the bus WOULD HAVE on board at various points in the route
  foreach bus_passengers [
    let passenger ?
    set passenger lput "b" passenger ; b stands for 'actually on board' as opposed to d; 'already dropped off'
    set has lput passenger has
  ]
  
  ; get all routes for the amount of levels you have
  let possible_routes []
  set possible_routes [ [ 2 1 ] [ 2 4 ] [ 2 3 ] [ 5 6 ] [ 5 7 ] [ 5 3 ] ] ; <-- temporary code
  set possible_routes get_potential_routes bus_stop level
  
  show possible_routes
  
  ; determine utility per route  
  let utils_routes []
  foreach possible_routes [
    let u 0
    let would_have has
    let this_route [] 
    foreach ? [ ; for each station on the route
      let return_list actual_utility ? would_have 
      set u u + item 0 return_list
      set would_have item 1 return_list
    ]
    set this_route lput u this_route
    set this_route lput ? this_route
    set this_route lput would_have this_route
    set utils_routes lput this_route utils_routes
  ]
  
  show "all possible routes and their utilities"
  foreach utils_routes [
    show item 1 ?
    show item 0 ?
  ]
  
  ; get the route with max utility
  let max_util -100 
  let route []
  let dropoff_intent_dirty []
  foreach utils_routes [
    let u item 0 ?
    if u > max_util [
      set max_util u
      set route item 1 ?
      set dropoff_intent_dirty item 2 ?
    ]    
  ]
  
  ; clean dropoff_intent_dirty
  let dropoff_intent_clean []
  foreach dropoff_intent_dirty [
    set dropoff_intent_clean lput item 0 ? dropoff_intent_clean
  ]
  set dropoff_intent dropoff_intent_clean
  
  report route 
end

to-report actual_utility [ bus_stop would_have ]
  show ( word "departing for bus stop " bus_stop " the bus would have these on board: " would_have )
  
  let n_on_board 0 ; we need to find out how many seats we have left in order to determine how many we can pick up
  foreach would_have [
    if item 2 ? = "b" [
      set n_on_board n_on_board + 1
    ]
  ]
  let n_free_spaces bus_capacity - n_on_board
  let alpha n_free_spaces / bus_capacity ; the parameter that weighs desire to pick-up versus desire to drop-off
   
  ; model potential dropoffs
  let n_dropoff 0
  let iter n-values length would_have [ ? ]
  foreach iter [
    let would_passenger item ? would_have ; check if we can drop off hypothetical passengers that we'd potentially be carrying if we arrived here
    if ( item 1 would_passenger = bus_stop ) and ( item 2 would_passenger = "b" ) [
      set would_passenger replace-item 2 would_passenger "d"
      set would_have replace-item ? would_have would_passenger
      set n_dropoff n_dropoff + 1
    ]
  ]
  set n_free_spaces n_free_spaces + n_dropoff
  
  ; prepare variables
  let destinations n-values 24 [0] ; we need to know which destinations the passengers on-board want so that we can check for overlap
  foreach would_have [
    set destinations replace-item item 1 ? destinations 1
  ]
  
  ; model potential pickups
  let n_overlap 0
  let n_potential_pickup 0
  
  ; passengers with overlapping destinations get priority in picking up
  foreach get-passengers-at-stop bus_stop [
    if n_free_spaces > 0 [
      ; only consider those passengers that other busses do not already have a plan for
      ; or passengers that we have already modelled to pick up ( in route 2-3-2-3 we pick up passengers at station 2 only once)
      if (not (member? (item 0 ?) item bus_stop has_plan)) and (not ( member? (item 0 ?) slice 0 would_have )) [  
        let temp_destination item 1 ?
        if item temp_destination destinations = 1 [
          let would_passenger ?
          set would_passenger lput "b" would_passenger
          set would_have lput would_passenger would_have
          set n_overlap n_overlap + 1
          set n_potential_pickup n_potential_pickup + 1
          set n_free_spaces n_free_spaces - 1
        ]
      ]
    ]
  ]

  ; passengers with non overlapping destinations may enter if there is still room
  foreach get-passengers-at-stop bus_stop [
    if n_free_spaces > 0 [
      if (not (member? (item 0 ?) item bus_stop has_plan)) and (not ( member? (item 0 ?) slice 0 would_have )) [        
        let temp_destination item 1 ?
        if item temp_destination destinations = 0 [
          let would_passenger ?
          set would_passenger lput "b" would_passenger
          set would_have lput would_passenger would_have
          set n_potential_pickup n_potential_pickup + 1
          set n_free_spaces n_free_spaces - 1
        ]
      ]
    ]
  ]
  
  ; determine utility
  let n_pickup mean list n_potential_pickup n_overlap  ;set pickups to mean of possible pickups and number of passengers with same destination as the ones onboard
  let utility (1 - alpha) * n_dropoff + alpha * n_pickup
  
  ; prepare return variables
  let return_list []
  set return_list lput utility return_list
  set return_list lput would_have return_list
  
  show ( word "when we get there, utility would be " item 0 return_list " and these would be on board: " item 1 return_list)
  
  report return_list
end


to-report get_potential_routes [ bus_stop level ]
  let potential_routes []
  let l []
  set l lput bus_stop l
  set potential_routes lput l potential_routes
  
  foreach n-values level [ ? ] [
    let potential_routes_temp []
    foreach potential_routes [
        let potential_routes_from_here link_route ?  
        foreach potential_routes_from_here [
          set potential_routes_temp lput ? potential_routes_temp
        ]
    ]
    set potential_routes potential_routes_temp
  ]
  
  foreach potential_routes [
    if length ? < level [
     set potential_routes remove ? potential_routes 
    ]
  ]
  
  let iter n-values length potential_routes [ ? ]
  foreach iter [ 
    set potential_routes replace-item ? potential_routes but-first item ? potential_routes
  ]
  
  report potential_routes  
end 

to-report link_route [ route_so_far ]
  let potential_routes []
  
  let connecting_nodes item (last route_so_far) graph
  foreach connecting_nodes [
    let potential_route lput ? route_so_far
    set potential_routes lput potential_route potential_routes
  ]
  report potential_routes
end

;
;to-report choose_next_station [ bus_stop level picked_up ]
;  ; Utility recursion function
;  ; Args:
;  ;   @bus_stop
;  ;   @level: level of recursion
;  ;
;  ; Return:
;  ;   @max of utility
;
;;  show " " 
;;  show "enter choose_next_station"
;;  show "level"
;;  show level
;
;  ; recursion base step
;  if level <= 0 [
;    let report_value []
;    set report_value lput [] report_value
;    set report_value lput 0 report_value
;
;    report report_value
;  ]
;
;  ; get connecting nodes
;  let connecting_nodes item bus_stop graph
;
;  let utilities []
;  let routes_1 []
;  let max_utility -1000
;
;  foreach connecting_nodes [
;
;    let bram actual_utility ? picked_up
;
;    ; Get the utility for each of the connecting nodes, with level = level - 1
;    let return_list choose_next_station ? (level - 1) (item 1 bram)  ; (recursion step)
;
;    let u item 1 return_list    
;    set u u + item 0 bram
;
;    if u > max_utility [
;      set max_utility u
;    ]
;
;    set utilities lput u utilities
;    set routes_1 lput item 0 return_list routes_1
;  ]
;
;  ; Get list of max_utilities. If there are multiple stations with the same
;  ; utility, then randomly choose one of those stations
;  let max_utility_indices []
;  let index 0
;
;  foreach utilities [
;    if ? = max_utility [
;      set max_utility_indices lput index max_utility_indices
;    ]
;    set index index + 1
;  ]
;  
;  show "route modelled so far"
;  show routes_1
;  show "we are considering bus stop"
;  show bus_stop
;  show "stations we can get to from here"
;  show connecting_nodes
;  show "utilities"
;  show utilities  
;
;  let select_node item random length max_utility_indices max_utility_indices  ; random bus_stop with the max utility
;  let chosen_route item select_node routes_1
;  set chosen_route lput item select_node connecting_nodes chosen_route
;  
;;  show "chosen_route (read backwards)"
;;  show item select_node routes_1
;;  show chosen_route
;
;  let report_list []
;  set report_list lput chosen_route report_list
;  set report_list lput max_utility report_list
;
;  report report_list
;end
;
;
;to-report actual_utility [ bus_stop picked_up ]
;  ; Compute the utility on traveling to 'bus stop'
;  ; Args:
;  ;   @bus_stop
;  ;   @picked_up: potential passenger pickups in parent bus stop. list of passenger ids
;  ; Return:
;  ;   [ @utility @potential_pickups ]
;
;  ; 'Droppable' passengers in the potential next bus stop (dropoffs)
;  let dropoffs 0
;  foreach bus_passengers [
;
;    ; FIXME: multiple dropoffs - minor (e.g. route: 2 3 2 3 2 3)
;     if item 1 ? = bus_stop [
;       set dropoffs dropoffs + 1
;     ]
;  ]
;  ; "potential" dropoffs
;  foreach picked_up [
;     if item 1 ? = bus_stop [
;       set dropoffs dropoffs + 1
;     ]
;  ]
;
;  ; Free spaces in the bus
;  let free_spaces free-spaces-on-bus
;  set free_spaces free_spaces - length picked_up
;  set free_spaces free_spaces + dropoffs
;
;  ; set number of passengers at stop to number of passengers without a plan
;  let number_have_plan length item bus_stop has_plan
;  let number_at_stop passenger-count-at-bus-stop bus_stop - number_have_plan
;
;  ; destination list
;  let destinations n-values 24 [0]
;
;  foreach bus_passengers [
;    set destinations replace-item item 1 ? destinations 1
;  ]
;  foreach picked_up [
;    set destinations replace-item item 1 ? destinations 1
;  ]
;
;  let remaining_spaces free_spaces
;  ; Potential pickups
;  let potential_pickups []
;
;  let overlapp 0
;  foreach get-passengers-at-stop bus_stop [
;    if remaining_spaces > 0 [
;      if not (member? (item 0 ?) item bus_stop has_plan) [
;        ; overlapping destinations
;        let temp_destination item 1 ?
;        if item temp_destination destinations = 1 [
;          set overlapp overlapp + 1
;          set potential_pickups lput ? potential_pickups
;          set remaining_spaces remaining_spaces - 1
;        ]
;      ]
;    ]
;  ]
;
;  foreach get-passengers-at-stop bus_stop [
;    if remaining_spaces > 0 [
;      if not (member? (item 0 ?) item bus_stop has_plan) [
;        ; non overlapping destinations
;        let temp_destination item 1 ?
;        if item temp_destination destinations = 0 [
;          set potential_pickups lput ? potential_pickups
;          set remaining_spaces remaining_spaces - 1
;        ]
;      ]
;    ]
;  ]
;
;  ; alpha
;  let alpha free_spaces / bus_capacity
;  ; set pickups to mean of possible pickups and number of passengers with same destination as the ones onboard
;  ; only do this if the bus is not empty?
;  let pickups mean list length potential_pickups overlapp
;  let utility_value (1 - alpha) * dropoffs + alpha * pickups
;
;  let val []
;  set val lput utility_value val
;  set val lput potential_pickups val
;
;  report val
;
;end

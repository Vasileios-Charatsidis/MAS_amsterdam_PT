; This file contains all functions regarding communication between buses
; This is an include-file to agents.nls.
;
; All the variables in buses-own and globals can be accessed here

; A bus read its messages before inferring what route it should take
; The variable has_plan is updated, it will help the bus focus on helping the correct passengers
; passengers that have been dropped off since the last message can be forgotten, lest the variable has_plan doesn't grow too large
; once the route has been inferred, a bus sends a message to all other buses letting them know what passengers it will help on its route

to communication
  ifelse bus_id = 24 [ ; if this bus is the oracle
    foreach inbox [
       if item 0 ? = ticks - 1 [ ; only consider 'fresh' messages
         ; unpack message
         let requester_bus_id item 1 ?
         let msg item 2 ?
         let bus_stop item 0 msg
         let has item 1 msg
         
         ; determine route for the requester
         let return_list determine_route bus_stop requester_bus_id has ; ( messages regarding bidding are included in the determine_route function )
         
         ; send message to the requester
         let route item 0 return_list
         let dropoff_intent_requester item 1 return_list
         let pickup_intent_requester item 2 return_list
         send-message requester_bus_id ( list 1 route dropoff_intent_requester pickup_intent_requester )
       ]
    ]

   if length known_route = 0 and current_stop > -1 [
     let has []
     foreach bus_passengers [
       let passenger ?
       set passenger lput "b" passenger ; b stands for 'actually on board' as opposed to d; 'already dropped off'
       set has lput passenger has
     ]
     ; determine route for oracle
     let return_list determine_route current_stop 24 has; ( messages regarding bidding are included in the determine_route function )
     
     set known_route item 0 return_list
     set dropoff_intent item 1 return_list
     set pickup_intent item 2 return_list
   ]

  ][ ; if this bus is not the oracle

    ; if route has (almost) been completed, ask oracle for a new route
    ; if length known_route = 0 and current_stop > -1 and sent = False [
    if length known_route = 0 and next_stop > -1 and sent = False [
      ; ask oracle for route

       let has [] ; the people the bus HAS on board is the starting point for keeping track of which passengers the bus WOULD HAVE on board at various points in the route
       foreach bus_passengers [
         let passenger ?
         set passenger lput "b" passenger ; b stands for 'actually on board' as opposed to d; 'already dropped off'
         set has lput passenger has
       ]

       ; send-message 24 ( list current_stop has )
       set sent True
       send-message 24 ( list next_stop has dropped_off)
       set dropped_off []
    ]

    foreach inbox [
      if item 0 ? = ticks - 1 [ ; only consider 'fresh' messages
        let msg item 2 ?
        ifelse item 0 msg = 1 [
          digest_type_1 msg
          set sent False
        ] [
          digest_type_2 msg
        ]
      ]
    ]
  ]
end

to digest_type_1 [ msg ]
  ; Parse type 1 message
  ; Args
  ;   @msg
  ; Message format: [ 1 route dropoff_intent pickup_intent ]
  ;                     route: [station_1 station_2 ...]
  ;                     dropoff_intent: [ [pass_id1 pass_id2 ] [pass_id3] [pass_id4] ... ]
  ;                     pickup_intent:  [ [pass_id1 destid] [pass_id2 destid] ...]

  set known_route item 1 msg
  set dropoff_intent item 2 msg
  set pickup_intent item 3 msg

end


to digest_type_2 [ msg ]
  ; remove this passenger from pickup intent and dropoff intent, because another bus has a better plan for him/her
  let pass_id last msg
  set pickup_intent remove pass_id pickup_intent
  foreach dropoff_intent [
    if member? pass_id ? [
      let dropoff_intent_here remove pass_id ?
      set dropoff_intent replace-item ( position ? dropoff_intent ) dropoff_intent dropoff_intent_here
    ]
  ]
end
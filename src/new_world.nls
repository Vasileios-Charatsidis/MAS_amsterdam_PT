;to send_vote
;  ; On creation of a bus send a vote to the oracle
;
;  let message list "vote" bus_capacity
;  send-message 24 message
;
;end


to check_inbox
  ; Process the messages in the inbox

  ifelse bus_id = 24 [
    
    let free_spaces 0
    let vote_is_in False
    
    foreach inbox [
      ; check if vote
      let message item 2 ?

      if item 0 message = "vote" [
        set free_spaces ( free_spaces + item 1 message )
        set vote_is_in True
      ]

      if item 0 message = "bid" [
        ; TODO add position to position_belief
      ]
    ]

    if vote_is_in or count buses = 1 [
      let to_add get_second_opinion free_spaces
      if to_add [
        oracle_adds_bus 
      ]
    ]

  ] [
    foreach inbox [
      ; check if oracle needs your vote
      let message item 2 ?
      if message = "please start vote" [
        send-message 24 ( list "vote" free_spaces_on_bus )
      ]
    ]

  ]
  
  set inbox []

end

to add_fixed_buses
  if bus_id = 24 [
  ; at 0:00 add the 'night team'
    if length night_team > 0 [ ; add some busses at 6:00, one every tick
      add-bus item 0 night_team
      set night_team but-first night_team
    ]
    
    ; at 6:00 add the 'morning team'
    if ticks > 360 and length morning_team > 0 [ ; add some busses at 6:00, one every tick
      add-bus item 0 morning_team
      set morning_team but-first morning_team
    ]
  ]
  
end

to request_vote
  let n_buses count buses
  let bus_ids n-values n_buses [ 24 + ? ]
  foreach bus_ids [
    if ? != 24 [
      send-message ? "please start vote" 
    ]        
  ]
  set tick_of_vote ticks
end

to decide_start_vote
  ; Only oracle can decide to add buses to system
  
  if bus_id = 24 [
    
    ; decide whether to add a bus based on how much capacity there is in the world
    ; and how many people we estimate are in the world. Assume full buses.
    let decision_ratio (total_capacity / (total_capacity + total_passenger_count))   
            
    if decision_ratio < add_bus_threshold and tick_of_vote != (ticks - 1) and second_opinion [
      request_vote
    ]
    
    if decision_ratio < add_bus_threshold and not second_opinion [
      oracle_adds_bus
    ]
      
    ; keep track of growth history to help decide what size bus to add in the future
    set history lput decision_ratio but-first history
  ]
  
end

to oracle_adds_bus  
  ; if we need to add a bus, determine what size
  let need new_bus_need
  if need < need_thresh_1 [
    ifelse need < need_thresh_2 [
      ifelse need < need_thresh_3 [
        add-bus 3
        set total_capacity total_capacity + 150
      ][
      add-bus 2
      set total_capacity total_capacity + 60
      ]
    ][
    add-bus 1
    set total_capacity total_capacity + 12
    ]
  ] 
end

to-report get_second_opinion [ free-spaces ]
  ; this function should only be called by the oracle
  
  ; determine if we still need to add a new bus based on the buses' second opinion
  let decision_ratio (total_capacity / (total_capacity - free-spaces + total_passenger_count))
  
  let to_add False
  if decision_ratio < add_bus_threshold [    
    set to_add True
  ]
  
  report to_add  
end

to-report new_bus_need
  ; the need for a bus is determined by how steeply the amount of planless passengers increased in the past few ticks
  ; also influenced by the time of day, later in the day we'll be more hesitant to buy new busses

  let discounted 0 ; the factor with which we want to multiply need at the end of the day
  let angle linear_fit history
  let time_factor 1 - (( ( 1 - discounted ) * ticks ) / total_ticks_per_day )
  report angle * time_factor
end


to give_route

end

to-report get_global_business_extrema
  ; reports a list of the id's of the busiest and the calmest station in the system and their respective business
  ; global business of a station is defined as the average of its own business and it's neighboring stations' business
  ;
  ; return_list like [ [ bus_stop_id max_business ]
  ;                    [ bus_stop_id min_business ] ]

  let businesses []

  ; get every station's neighbourhood business
  let iter n-values 24 [ ? ]
  foreach iter [
    let global_business length get-passengers-at-stop ?
    let connecting_nodes item ? graph
    foreach connecting_nodes [
      set global_business global_business + length get-passengers-at-stop ?
    ]
    set global_business global_business / ( length connecting_nodes + 1 )
    set businesses lput global_business businesses
  ]

  ; get extrema
  let max_business max businesses
  let min_business min businesses
  let max_idx position max_business businesses
  let min_idx position min_business businesses

  ; prepare return_list
  report ( list ( list max_idx max_business ) ( list min_idx min_business ) )
end


to-report choose_next_stop
  ; From the current bus stop, choose the next bus stop to visit
  ; Currently we choose the bus stop with the maximum number of passengers
  ; return:
  ;  @ next_stop

  ; Get the connecting nodes of the current bus stop
  let connecting_nodes item current_stop graph

  let utilities []
  let max_utility -1000000

  ; 10 percent randomeness added. If 1, then the next stop will be randomly chosen
  let random_route [0 0 0 0 0 0 0 0 0 1]
  let r_idx random length random_route

  if (item r_idx random_route = 1) [
    let random_next_node random length connecting_nodes
    report item random_next_node connecting_nodes
  ]

  foreach connecting_nodes [
    ; Get the utility for each of the connecting nodes
    let u utility ?

    if u > max_utility [
      set max_utility u
    ]

    set utilities lput u utilities
  ]

  ; Get list of max_utilities. If there are multiple stations with the same
  ; utility, then randomly choose one of those stations
  let max_utility_indices []
  let index 0

  foreach utilities [
    if ? = max_utility [
      set max_utility_indices lput index max_utility_indices
    ]
    set index index + 1
  ]

  let select_node item random length max_utility_indices max_utility_indices

  report item select_node connecting_nodes

end


to-report utility [ bus_stop ]

  let dropoffs 0
  foreach bus_passengers [
     if item 1 ? = bus_stop [
       set dropoffs dropoffs + 1
     ]
  ]

  let passengers_at_stop get-passengers-at-stop bus_stop

  ; potential_pickups
  let potential_pickups min list length passengers_at_stop free_spaces_on_bus

  ; overalapping destinations
  let bus_destinations n-values 24 [0]
  foreach bus_passengers [
    let idx item 1 ?
    ; set bus_destinations position idx 1
    set bus_destinations replace-item idx bus_destinations 1
  ]

  let overlapp 0
  foreach passengers_at_stop [
    let destination item 1 ?
    if destination = 1 [
        set overlapp (overlapp + 1)
    ]
  ]

  ; alpha
  let alpha free_spaces_on_bus / bus_capacity
  ; set pickups to mean of possible pickups and number of passengers with same destination as the ones onboard
  ; only do this if the bus is not empty?
  let pickups mean list potential_pickups overlapp
  let utility_value (1 - alpha) * dropoffs + alpha * pickups

  ; This is experimental. This adds to the performance signigicantly
  ; The idea is to go to the node which is nearer to the passengers on board (currently takes the sum)
  ; It is quite intuitive for the following case:
  ;    If the number of potential_pickups and potential_dropoffs is the same for multiple nodes,
  ;    Then choose the node which helps multiple passengers.
  ; Further work could include choosing the weights of utility_value and total_help.
  let total_help 0
  foreach bus_passengers [
    let h help ? current_stop bus_stop

    set total_help (total_help + h)
  ]

  report utility_value + total_help

end


to dropoff_passengers

  foreach bus_passengers [
    ifelse item 1 ? = current_stop [
      drop-off-passenger item 0 ?
    ] [
      ; drop off if negative help
      let h help ? current_stop next_stop

      if h < 0 [
        drop-off-passenger item 0 ?
      ]
    ]
  ]

end


to pickup_passengers

  let free_spaces bus_capacity - (length bus_passengers)
  let passengers_at_stop get-passengers-at-stop current_stop

  ; Only pickup free_spaces number of passengers
  repeat min list free_spaces length passengers_at_stop [

    let r_passenger item random length passengers_at_stop passengers_at_stop
    let h help r_passenger current_stop next_stop

    if h > 0 [
        pick-up-passenger item 0 r_passenger
        set free_spaces (free_spaces - 1)
    ]
  ]

end


to decide_send_bid

end


to-report help [ passenger bus_stop_from bus_stop_to ]
  ; help is defined as the reduction in shortest travel distance to the destination from one station to another
  ; if destination is C and A-->C=7, B-->C=5, then help(A-->B)=2, regardless of the distance between A and B
  report ( item bus_stop_from item ( item 1 passenger ) distance_mat ) - ( item bus_stop_to item ( item 1 passenger ) distance_mat )
end
